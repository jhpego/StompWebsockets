"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const model_1 = require("./model");
const utils_1 = require("./utils");
const heartbeat_1 = require("./heartbeat");
var StompFrameStatus;
(function (StompFrameStatus) {
    StompFrameStatus[StompFrameStatus["COMMAND"] = 0] = "COMMAND";
    StompFrameStatus[StompFrameStatus["HEADERS"] = 1] = "HEADERS";
    StompFrameStatus[StompFrameStatus["BODY"] = 2] = "BODY";
    StompFrameStatus[StompFrameStatus["ERROR"] = 3] = "ERROR";
})(StompFrameStatus || (StompFrameStatus = {}));
const emptyFrame = new model_1.StompFrame('');
class StompFrameLayer {
    constructor(stream, options) {
        this.stream = stream;
        this.emitter = new model_1.StompEventEmitter();
        this.maxBufferSize = 10 * 1024;
        this.frame = emptyFrame;
        this.contentLength = -1;
        this.buffer = Buffer.alloc(0);
        this.status = StompFrameStatus.COMMAND;
        this.newlineFloodingResetTime = 1000;
        this.lastNewlineTime = 0;
        this.newlineCounter = 0;
        this.headerFilter = (headerName) => true;
        stream.emitter.on('data', (data) => this.onData(data));
        stream.emitter.on('end', () => this.onEnd());
        this.init(options);
        this.heartbeat = new heartbeat_1.Heartbeat(this, options && options.heartbeat);
    }
    init(options) {
        utils_1.log.debug("StompFrameLayer: initializing with options %j", options);
        if (options) {
            if (options.connectTimeout && options.connectTimeout > 0) {
                this.connectTimeout = setTimeout(() => this.stream.close(), options.connectTimeout);
            }
            if (options.newlineFloodingResetTime && options.newlineFloodingResetTime > 0) {
                this.newlineFloodingResetTime = options.newlineFloodingResetTime;
            }
            if (options.maxBufferSize && options.maxBufferSize > 0) {
                this.maxBufferSize = options.maxBufferSize;
            }
        }
    }
    /**
     * Transmit a frame using the underlying stream layer.
     */
    send(frame) {
        return __awaiter(this, void 0, void 0, function* () {
            let data = frame.command + '\n';
            let body = '';
            let headers = Object.keys(frame.headers).filter(this.headerFilter).sort();
            for (var key of headers) {
                data += key + ':' + escape(frame.headers[key]) + '\n';
            }
            if (frame.body.length > 0) {
                body = frame.body;
                if (!frame.headers.hasOwnProperty('suppress-content-length')) {
                    data += 'content-length:' + Buffer.byteLength(body) + '\n';
                }
            }
            data += '\n';
            if (body.length > 0) {
                data += body;
            }
            data += '\0';
            utils_1.log.silly("StompFrameLayer: sending frame data %j", data);
            yield this.stream.send(data);
            this.heartbeat.resetupOutgoingTimer();
        });
    }
    /**
     * Closes the underlying stream layer.
     */
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            utils_1.log.debug("StompFrameLayer: closing");
            yield this.stream.close();
        });
    }
    /**
     * Main entry point for frame parsing. It's a state machine that expects
     * the standard [ command - headers - body ] structure of a frame.
     */
    onData(data) {
        if (data.length === 1 && data[0] === 0) {
            // Just one byte incoming: it's a null-char for heart-beat.
            return;
        }
        this.buffer = Buffer.concat([this.buffer, data]);
        if (this.buffer.length <= this.maxBufferSize) {
            do {
                try {
                    if (this.status === StompFrameStatus.COMMAND) {
                        this.parseCommand();
                    }
                    if (this.status === StompFrameStatus.HEADERS) {
                        this.parseHeaders();
                    }
                    if (this.status === StompFrameStatus.BODY) {
                        this.parseBody();
                    }
                    if (this.status === StompFrameStatus.ERROR) {
                        this.parseError();
                    }
                }
                catch (err) {
                    utils_1.log.warn("StompFrameLayer: error while parsing data %O", err);
                    this.stream.close();
                    throw err;
                }
                // still waiting for command line, there is other data remaining
            } while (this.status === StompFrameStatus.COMMAND && this.hasLine());
        }
        else {
            this.error(new model_1.StompError('Maximum buffer size exceeded.'));
            this.stream.close();
        }
    }
    onEnd() {
        this.emitter.emit('end');
    }
    parseCommand() {
        while (this.hasLine()) {
            var commandLine = this.popLine();
            // command length security check: should be in 1 - 30 char range.
            if (commandLine.length > 0 && commandLine.length < 30) {
                this.frame = new model_1.StompFrame(commandLine.toString().replace('\r', ''));
                this.contentLength = -1;
                this.incrementStatus();
                break;
            }
        }
    }
    /**
     * Parse and checks frame headers format. When content-length header is
     * detected, it can be used by the body parser.
     */
    parseHeaders() {
        var value;
        while (this.hasLine()) {
            var headerLine = this.popLine();
            if (headerLine.length === 0) {
                this.incrementStatus();
                break;
            }
            else {
                var kv = headerLine.toString().replace('\r', '').split(':');
                if (kv.length < 2) {
                    // this.error(new model_1.StompError('Error parsing header', `No ':' in line '${headerLine}'`));
                    break;
                } else {
                    value = kv.slice(1).join(':');
                    this.frame.setHeader(kv[0], unescape(value));
                    if (kv[0] === 'content-length') {
                        this.contentLength = parseInt(value);
                    }
                }

            }
        }
    }
    /**
     * Parse frame body, using both the content-length header and null char to
     * determine the frame end.
     */
    parseBody() {
        var bufferBuffer = new Buffer(this.buffer);
        if (this.contentLength > -1) {
            // consume data using content-length header
            const remainingLength = this.contentLength - this.frame.body.length;
            if (remainingLength <= bufferBuffer.length) {
                this.appendToBody(bufferBuffer.slice(0, remainingLength));
                this.buffer = bufferBuffer.slice(remainingLength, bufferBuffer.length);
                if (this.buffer.indexOf('\0') === 0) {
                    this.buffer = this.buffer.slice(1);
                }
                this.contentLength = -1;
                this.emitFrame();
            }
        }
        else {
            // consume data using the null-char end
            const index = this.buffer.indexOf('\0');
            if (index == -1) {
                this.appendToBody(this.buffer);
                this.buffer = Buffer.alloc(0);
            }
            else {
                // The end of the frame has been identified, finish creating it
                this.appendToBody(this.buffer.slice(0, index));
                this.buffer = this.buffer.slice(index + 1);
                this.emitFrame();
            }
        }
    }
    appendToBody(buffer) {
        this.frame.body += buffer.toString();
    }
    emitFrame() {
        // Emit the frame and reset
        utils_1.log.silly("StompFrameLayer: received frame %j", this.frame);
        this.emitter.emit('frame', this.frame); // Event emit to catch any frame emission
        if (this.connectTimeout) { // first frame received. Cancel disconnect timeout
            clearTimeout(this.connectTimeout);
            delete this.connectTimeout;
        }
        this.incrementStatus();
    }
    /**
     * Parses the error
     */
    parseError() {
        var index = this.buffer.indexOf('\0');
        if (index > -1) {
            // End of the frame is already in buffer
            this.buffer = this.buffer.slice(index + 1);
            this.incrementStatus();
        }
        else {
            // End of the frame not seen yet
            this.buffer = Buffer.alloc(0);
        }
    }
    /**
     * Pops a new line from the stream
     * @return {Buffer} the new line available
     */
    popLine() {
        const now = Date.now();
        if (now - this.lastNewlineTime > this.newlineFloodingResetTime) {
            this.newlineCounter = 0;
            this.lastNewlineTime = now;
        }
        if (this.newlineCounter++ > 100) { //security check for newline char flooding
            throw new Error('Newline flooding detected.');
        }
        var index = this.buffer.indexOf('\n');
        var line = this.buffer.slice(0, index);
        this.buffer = this.buffer.slice(index + 1);
        return line;
    }
    /**
     * Check if there is a new line in the current stream chunk
     * @return {boolean}
     */
    hasLine() {
        return (this.buffer.indexOf('\n') > -1);
    }
    /**
     * Emits a new StompFrameError and sets the current status to ERROR
     * @param  {StompFrameError} error
     */
    error(error) {
        utils_1.log.debug("StompFrameLayer: stomp error %O", error);
        this.emitter.emit('error', error);
        this.status = StompFrameStatus.ERROR;
    }
    /**
     * Set the current status to the next available, otherwise it returns in COMMAND status.
     */
    incrementStatus() {
        if (this.status === StompFrameStatus.BODY || this.status === StompFrameStatus.ERROR) {
            this.status = StompFrameStatus.COMMAND;
            this.newlineCounter = 0;
        }
        else {
            this.status++;
        }
    }
}
exports.StompFrameLayer = StompFrameLayer;
function unescape(value) {
    if (value.indexOf('\\') >= 0) {
        if (value.indexOf('\\t') >= 0) {
            throw new Error("Unsupported escape sequence detected.");
        }
        value = value
            .replace(/\\n/g, '\n')
            .replace(/\\c/g, ':')
            .replace(/\\\\/g, '\\')
            .replace(/\\r/g, '\r');
    }
    return value;
}
function escape(value) {
    if (value.match(/[\t\n\r\:\\]/g)) {
        if (value.indexOf('\t') >= 0) {
            throw new Error("Unsupported character detected.");
        }
        value = value
            .replace(/\\/g, '\\\\')
            .replace(/\n/g, '\\n')
            .replace(/\:/g, '\\c')
            .replace(/\r/g, '\\r');
    }
    return value;
}
