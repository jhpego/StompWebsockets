"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const model_1 = require("./model");
const protocol_1 = require("./protocol");
const utils_1 = require("./utils");
class StompSessionLayer {
    constructor(frameLayer, listener) {
        this.frameLayer = frameLayer;
        this.data = new model_1.StompSessionData();
        this.internalErrorHandler = (e) => utils_1.log.warn("StompSessionLayer: internal error %O", e);
        utils_1.log.debug("StompSessionLayer: initializing");
        if (typeof listener === 'function') {
            this.listener = new listener(this);
        }
        else {
            this.listener = listener;
        }
        frameLayer.emitter.on('frame', (frame) => this.onFrame(frame));
        frameLayer.emitter.on('error', (error) => this.listener.onProtocolError(error));
        frameLayer.emitter.on('end', () => this.onEnd());
    }
    onFrame(frame) {
        utils_1.log.silly("StompSessionLayer: received command %s", frame.command);
        if (this.isValidCommand(frame.command)) {
            const command = this.inboundCommands[frame.command];
            const validators = command.validators;
            let validation;
            for (let validator of validators) {
                validation = validator(frame, this.data);
                if (!validation.isValid) {
                    this.onError(new model_1.StompError(validation.message, validation.details));
                    return;
                }
            }
            this.handleFrame(command, frame);
        }
        else {
            this.onError(new model_1.StompError('No such command', `Unrecognized Command '${frame.command}'`));
        }
    }
    handleFrame(command, frame) {
        utils_1.log.silly("StompSessionLayer: handling frame %j", frame);
        command.handle(frame, this);
    }
    sendFrame(frame) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.frameLayer.send(frame);
        });
    }
    onEnd() {
        utils_1.log.debug("StompFrameLayer: end event");
        this.listener.onEnd();
    }
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            utils_1.log.debug("StompFrameLayer: closing");
            return this.frameLayer.close();
        });
    }
    isValidCommand(command) {
        return (command && command.length < 20 && this.inboundCommands[command]);
    }
}
exports.StompSessionLayer = StompSessionLayer;
class StompServerSessionLayer extends StompSessionLayer {
    constructor(frameLayer, listener) {
        super(frameLayer, listener);
        this.protocol = protocol_1.StompProtocolHandlerV10;
    }
    get inboundCommands() {
        return this.protocol.client;
    }
    handleFrame(command, frame) {
        const acceptVersion = frame.command === 'CONNECT' && frame.headers && frame.headers['accept-version'];
        if (this.data.authenticated || frame.command === 'CONNECT') {
            try {
                if (acceptVersion) {
                    utils_1.log.silly("StompServerSessionLayer: session %s switching protocol %s", this.data.id, acceptVersion);
                    this.switchProtocol(acceptVersion);
                }
                super.handleFrame(command, frame);
            }
            catch (error) {
                const headers = { message: error.message };
                this.error(headers, error.details).catch(this.internalErrorHandler);
            }
        }
        else {
            this.error({ message: 'You must first issue a CONNECT command' }).catch(this.internalErrorHandler);
        }
    }
    switchProtocol(acceptVersion) {
        if (acceptVersion.indexOf('1.2') >= 0) {
            this.protocol = protocol_1.StompProtocolHandlerV12;
        }
        else if (acceptVersion.indexOf('1.1') >= 0) {
            this.protocol = protocol_1.StompProtocolHandlerV11;
        }
        else if (acceptVersion.indexOf('1.0') < 0) {
            throw new Error('Supported protocol versions are: 1.0, 1.1, 1.2');
        }
    }
    onError(error) {
        this.error({ message: error.message }, error.details).catch(this.internalErrorHandler);
    }
    connected(headers) {
        return __awaiter(this, void 0, void 0, function* () {
            utils_1.log.debug("StompServerSessionLayer: sending CONNECTED frame %j", headers);
            this.data.authenticated = true;
            const heartbeat = this.frameLayer.heartbeat &&
                this.frameLayer.heartbeat.optionsString && {
                "heart-beat": this.frameLayer.heartbeat.optionsString
            };
            const _headers = Object.assign(Object.assign(Object.assign({}, headers), { version: this.protocol.version }), heartbeat);
            yield this.sendFrame(new model_1.StompFrame('CONNECTED', _headers));
        });
    }
    message(headers, body) {
        return __awaiter(this, void 0, void 0, function* () {
            utils_1.log.silly("StompServerSessionLayer: sending MESSAGE frame %j %s", headers, body);
            yield this.sendFrame(new model_1.StompFrame('MESSAGE', headers, body));
        });
    }
    receipt(headers) {
        return __awaiter(this, void 0, void 0, function* () {
            utils_1.log.silly("StompServerSessionLayer: sending RECEIPT frame %j", headers);
            yield this.sendFrame(new model_1.StompFrame('RECEIPT', headers));
        });
    }
    error(headers, body) {
        return __awaiter(this, void 0, void 0, function* () {
            utils_1.log.debug("StompServerSessionLayer: sending ERROR frame %j %s", headers, body);
            yield this.sendFrame(new model_1.StompFrame('ERROR', headers, body));
            yield this.frameLayer.close();
        });
    }
}
exports.StompServerSessionLayer = StompServerSessionLayer;
class StompClientSessionLayer extends StompSessionLayer {
    constructor(frameLayer, listener) {
        super(frameLayer, listener);
        this.protocol = protocol_1.StompProtocolHandlerV10;
    }
    get inboundCommands() {
        return this.protocol.server;
    }
    onError(error) {
        this.listener.onProtocolError(error);
    }
    handleFrame(command, frame) {
        if (frame.command === 'CONNECTED') {
            utils_1.log.debug("StompClientSessionLayer: received CONNECTED frame %j", frame.headers);
            if (frame.headers.version === '1.1') {
                this.protocol = protocol_1.StompProtocolHandlerV11;
            }
            if (frame.headers.version === '1.2') {
                this.protocol = protocol_1.StompProtocolHandlerV12;
            }
        }
        try {
            super.handleFrame(command, frame);
        }
        catch (error) {
            this.internalErrorHandler(error);
        }
    }
    connect(headers) {
        return __awaiter(this, void 0, void 0, function* () {
            utils_1.log.debug("StompClientSessionLayer: sending CONNECT frame %j", headers);
            const heartbeat = this.frameLayer.heartbeat &&
                this.frameLayer.heartbeat.optionsString && {
                "heart-beat": this.frameLayer.heartbeat.optionsString
            };
            const _headers = Object.assign(Object.assign(Object.assign({}, headers), { 'accept-version': '1.0,1.1,1.2' }), heartbeat);
            yield this.sendFrame(new model_1.StompFrame('CONNECT', _headers));
        });
    }
    send(headers, body) {
        return __awaiter(this, void 0, void 0, function* () {
            utils_1.log.silly("StompClientSessionLayer: sending SEND frame %j %s", headers, body);
            yield this.sendFrame(new model_1.StompFrame('SEND', headers, body));
        });
    }
    subscribe(headers) {
        return __awaiter(this, void 0, void 0, function* () {
            utils_1.log.debug("StompClientSessionLayer: sending SUBSCRIBE frame %j", headers);
            yield this.sendFrame(new model_1.StompFrame('SUBSCRIBE', headers));
        });
    }
    unsubscribe(headers) {
        return __awaiter(this, void 0, void 0, function* () {
            utils_1.log.debug("StompClientSessionLayer: sending UNSUBSCRIBE frame %j", headers);
            yield this.sendFrame(new model_1.StompFrame('UNSUBSCRIBE', headers));
        });
    }
    begin(headers) {
        return __awaiter(this, void 0, void 0, function* () {
            utils_1.log.silly("StompClientSessionLayer: sending BEGIN frame %j", headers);
            yield this.sendFrame(new model_1.StompFrame('BEGIN', headers));
        });
    }
    commit(headers) {
        return __awaiter(this, void 0, void 0, function* () {
            utils_1.log.silly("StompClientSessionLayer: sending COMMIT frame %j", headers);
            yield this.sendFrame(new model_1.StompFrame('COMMIT', headers));
        });
    }
    abort(headers) {
        return __awaiter(this, void 0, void 0, function* () {
            utils_1.log.silly("StompClientSessionLayer: sending ABORT frame %j", headers);
            yield this.sendFrame(new model_1.StompFrame('ABORT', headers));
        });
    }
    ack(headers) {
        return __awaiter(this, void 0, void 0, function* () {
            utils_1.log.silly("StompClientSessionLayer: sending ACK frame %j", headers);
            yield this.sendFrame(new model_1.StompFrame('ACK', headers));
        });
    }
    nack(headers) {
        return __awaiter(this, void 0, void 0, function* () {
            utils_1.log.silly("StompClientSessionLayer: sending NACK frame %j", headers);
            yield this.sendFrame(new model_1.StompFrame('NACK', headers));
        });
    }
    disconnect(headers) {
        return __awaiter(this, void 0, void 0, function* () {
            utils_1.log.debug("StompClientSessionLayer: sending DISCONNECT frame %j", headers);
            yield this.sendFrame(new model_1.StompFrame('DISCONNECT', headers));
        });
    }
}
exports.StompClientSessionLayer = StompClientSessionLayer;
