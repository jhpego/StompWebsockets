import { StompFrame, StompHeaders, StompError, StompSessionData } from './model';
import { StompFrameLayer } from './frame';
import { StompCommandListener, StompClientCommandListener, StompServerCommandListener, StompCommand, StompCommands } from './protocol';
export interface StompSession<L extends StompCommandListener> {
    readonly listener: L;
    readonly data: StompSessionData;
    close(): Promise<void>;
}
export interface StompCommandListenerConstructor<S extends StompSessionLayer<L>, L extends StompCommandListener> {
    new (session: S): L;
}
export interface StompClientCommandListenerConstructor extends StompCommandListenerConstructor<StompServerSessionLayer, StompClientCommandListener> {
}
export interface StompServerCommandListenerConstructor extends StompCommandListenerConstructor<StompClientSessionLayer, StompServerCommandListener> {
}
export declare abstract class StompSessionLayer<L extends StompCommandListener> implements StompSession<L> {
    readonly frameLayer: StompFrameLayer;
    protected abstract get inboundCommands(): StompCommands<L>;
    readonly data: StompSessionData;
    internalErrorHandler: (e: Error) => any;
    readonly listener: L;
    constructor(frameLayer: StompFrameLayer, listener: L | (new (session: any) => L));
    private onFrame;
    protected handleFrame(command: StompCommand<L>, frame: StompFrame): void;
    protected sendFrame(frame: StompFrame): Promise<void>;
    private onEnd;
    close(): Promise<void>;
    protected abstract onError(error: StompError): void;
    private isValidCommand;
}
export declare class StompServerSessionLayer extends StompSessionLayer<StompClientCommandListener> {
    private protocol;
    protected get inboundCommands(): StompCommands<StompClientCommandListener>;
    constructor(frameLayer: StompFrameLayer, listener: StompCommandListenerConstructor<StompServerSessionLayer, StompClientCommandListener> | StompClientCommandListener);
    protected handleFrame(command: StompCommand<StompClientCommandListener>, frame: StompFrame): void;
    private switchProtocol;
    protected onError(error: StompError): void;
    connected(headers: StompHeaders): Promise<void>;
    message(headers: StompHeaders, body?: string): Promise<void>;
    receipt(headers: StompHeaders): Promise<void>;
    error(headers?: StompHeaders, body?: string): Promise<void>;
}
export declare class StompClientSessionLayer extends StompSessionLayer<StompServerCommandListener> {
    private protocol;
    protected get inboundCommands(): StompCommands<StompServerCommandListener>;
    constructor(frameLayer: StompFrameLayer, listener: StompCommandListenerConstructor<StompClientSessionLayer, StompServerCommandListener> | StompServerCommandListener);
    protected onError(error: StompError): void;
    protected handleFrame(command: StompCommand<StompServerCommandListener>, frame: StompFrame): void;
    connect(headers: StompHeaders): Promise<void>;
    send(headers: StompHeaders, body?: string): Promise<void>;
    subscribe(headers: StompHeaders): Promise<void>;
    unsubscribe(headers: StompHeaders): Promise<void>;
    begin(headers: StompHeaders): Promise<void>;
    commit(headers: StompHeaders): Promise<void>;
    abort(headers: StompHeaders): Promise<void>;
    ack(headers: StompHeaders): Promise<void>;
    nack(headers: StompHeaders): Promise<void>;
    disconnect(headers?: StompHeaders): Promise<void>;
}
