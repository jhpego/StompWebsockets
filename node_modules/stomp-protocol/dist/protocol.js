"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const model_1 = require("./model");
const validators_1 = require("./validators");
const utils_1 = require("./utils");
exports.StompProtocolHandlerV10 = {
    version: '1.0',
    client: {
        CONNECT: {
            validators: [],
            handle(frame, session) {
                session.listener.connect(frame.headers);
                utils_1.log.debug("StompProtocolHandler: session %s connected", session.data.id);
            }
        },
        SEND: {
            validators: [validators_1.requireHeader('destination')],
            handle(frame, session) {
                session.listener.send(frame.headers, frame.body);
                utils_1.log.silly("StompProtocolHandler: session %s sent frame %j", session.data.id, frame);
            }
        },
        SUBSCRIBE: {
            validators: [validators_1.requireHeader('destination')],
            handle(frame, session) {
                session.listener.subscribe(frame.headers);
                const destination = getDestinationKey(frame.headers);
                utils_1.log.debug("StompProtocolHandler: session %s subscribed to destination %s", session.data.id, destination);
            }
        },
        UNSUBSCRIBE: {
            validators: [validators_1.requireOneHeader('destination', 'id')],
            handle(frame, session) {
                const destination = getDestinationKey(frame.headers);
                session.listener.unsubscribe(frame.headers);
                utils_1.log.debug("StompProtocolHandler: session %s unsubscribed from destination %s", session.data.id, destination);
            }
        },
        BEGIN: {
            validators: [validators_1.requireHeader('transaction')],
            handle(frame, session) {
                const transaction = frame.headers && frame.headers.transaction;
                session.listener.begin(frame.headers);
                utils_1.log.silly("StompProtocolHandler: session %s begin transaction %s", session.data.id, transaction);
            }
        },
        COMMIT: {
            validators: [validators_1.requireHeader('transaction')],
            handle(frame, session) {
                const transaction = frame.headers && frame.headers.transaction;
                session.listener.commit(frame.headers);
                utils_1.log.silly("StompProtocolHandler: session %s committed transaction %s", session.data.id, transaction);
            }
        },
        ABORT: {
            validators: [validators_1.requireHeader('transaction')],
            handle(frame, session) {
                const transaction = frame.headers && frame.headers.transaction;
                session.listener.abort(frame.headers);
                utils_1.log.silly("StompProtocolHandler: session %s aborted transaction %s", session.data.id, transaction);
            }
        },
        ACK: {
            validators: [validators_1.requireHeader('message-id')],
            handle(frame, session) {
                session.listener.ack(frame.headers);
                utils_1.log.silly("StompProtocolHandler: session %s ack %j", session.data.id, frame.headers);
            }
        },
        DISCONNECT: {
            validators: [],
            handle(frame, session) {
                session.listener.disconnect(frame.headers);
                session.close();
                utils_1.log.debug("StompProtocolHandler: session %s disconnected", session.data.id);
            }
        }
    },
    server: {
        CONNECTED: {
            validators: [],
            handle(frame, session) {
                session.listener.connected(frame.headers);
                utils_1.log.debug("StompProtocolHandler: session %s connected", session.data.id);
            }
        },
        MESSAGE: {
            validators: [validators_1.requireAllHeaders('destination', 'message-id')],
            handle(frame, session) {
                session.listener.message(frame.headers, frame.body);
                utils_1.log.silly("StompProtocolHandler: session %s received frame %j", session.data.id, frame);
            }
        },
        RECEIPT: {
            validators: [validators_1.requireHeader('receipt-id')],
            handle(frame, session) {
                session.listener.receipt(frame.headers);
                utils_1.log.silly("StompProtocolHandler: session %s sent receipt %j", session.data.id, frame);
            }
        },
        ERROR: {
            validators: [],
            handle(frame, session) {
                session.listener.error(frame.headers, frame.body);
                utils_1.log.debug("StompProtocolHandler: session %s sent error %j", session.data.id, frame);
            }
        }
    }
};
exports.StompProtocolHandlerV11 = {
    version: '1.1',
    client: {
        CONNECT: {
            validators: [validators_1.requireAllHeaders('accept-version', 'host')],
            handle: exports.StompProtocolHandlerV10.client.CONNECT.handle,
        },
        STOMP: {
            validators: [validators_1.requireAllHeaders('accept-version', 'host')],
            handle: exports.StompProtocolHandlerV10.client.CONNECT.handle,
        },
        SEND: exports.StompProtocolHandlerV10.client.SEND,
        SUBSCRIBE: {
            validators: [validators_1.requireAllHeaders('destination', 'id')],
            handle: exports.StompProtocolHandlerV10.client.SUBSCRIBE.handle,
        },
        UNSUBSCRIBE: {
            validators: [validators_1.requireHeader('id')],
            handle: exports.StompProtocolHandlerV10.client.UNSUBSCRIBE.handle,
        },
        BEGIN: exports.StompProtocolHandlerV10.client.BEGIN,
        COMMIT: exports.StompProtocolHandlerV10.client.COMMIT,
        ABORT: exports.StompProtocolHandlerV10.client.ABORT,
        ACK: {
            validators: [validators_1.requireAllHeaders('message-id', 'subscription')],
            handle: exports.StompProtocolHandlerV10.client.ACK.handle,
        },
        NACK: {
            validators: [validators_1.requireAllHeaders('message-id', 'subscription')],
            handle(frame, session) {
                session.listener.nack(frame.headers);
                utils_1.log.silly("StompProtocolHandler: session %s nack %j", session.data.id, frame.headers);
            }
        },
        DISCONNECT: exports.StompProtocolHandlerV10.client.DISCONNECT
    },
    server: {
        CONNECTED: {
            validators: [validators_1.requireHeader('version')],
            handle: exports.StompProtocolHandlerV10.server.CONNECTED.handle
        },
        MESSAGE: {
            validators: [validators_1.requireAllHeaders('destination', 'message-id', 'subscription')],
            handle: exports.StompProtocolHandlerV10.server.MESSAGE.handle
        },
        RECEIPT: exports.StompProtocolHandlerV10.server.RECEIPT,
        ERROR: exports.StompProtocolHandlerV10.server.ERROR
    }
};
exports.StompProtocolHandlerV12 = {
    version: '1.2',
    client: {
        CONNECT: exports.StompProtocolHandlerV11.client.CONNECT,
        STOMP: exports.StompProtocolHandlerV11.client.STOMP,
        SEND: exports.StompProtocolHandlerV11.client.SEND,
        SUBSCRIBE: exports.StompProtocolHandlerV11.client.SUBSCRIBE,
        UNSUBSCRIBE: exports.StompProtocolHandlerV11.client.UNSUBSCRIBE,
        BEGIN: exports.StompProtocolHandlerV11.client.BEGIN,
        COMMIT: exports.StompProtocolHandlerV11.client.COMMIT,
        ABORT: exports.StompProtocolHandlerV11.client.ABORT,
        ACK: {
            validators: [validators_1.requireHeader('id')],
            handle: exports.StompProtocolHandlerV11.client.ACK.handle
        },
        NACK: {
            validators: [validators_1.requireHeader('id')],
            handle: exports.StompProtocolHandlerV11.client.NACK.handle
        },
        DISCONNECT: exports.StompProtocolHandlerV11.client.DISCONNECT
    },
    server: {
        CONNECTED: exports.StompProtocolHandlerV11.server.CONNECTED,
        MESSAGE: exports.StompProtocolHandlerV11.server.MESSAGE,
        RECEIPT: exports.StompProtocolHandlerV11.server.RECEIPT,
        ERROR: exports.StompProtocolHandlerV11.server.ERROR
    }
};
function getDestinationKey(headers) {
    if (headers.id) {
        return 'id:' + headers.id;
    }
    if (headers.destination) {
        return 'dest:' + headers.destination;
    }
    throw new model_1.StompError('You must specify destination or id header.');
}
