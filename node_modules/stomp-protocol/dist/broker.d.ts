import { StompHeaders, StompConfig, StompMessage } from "./model";
import { StompServerSessionLayer } from "./session";
import { GenericSocket } from "./utils";
export declare type SessionIdGenerator = () => string;
export interface StompBrokerListener {
    sessionEnd(sessionId: string): void;
    sessionError(sessionId: string, error: Error): void;
    connecting(sessionId: string, headers: StompHeaders): Promise<void>;
    disconnecting(sessionId: string, headers: StompHeaders): Promise<void>;
    incomingMessage(sessionId: string, headers: StompHeaders, body: string | undefined): Promise<void>;
    subscribing(sessionId: string, subscription: Subscription): Promise<void>;
    unsubscribing(sessionId: string, subscription: Subscription): Promise<void>;
    acknowledging(sessionId: string, acknowledge: Acknowledge): Promise<void>;
    beginningTransaction(sessionId: string, transactionId: string): Promise<void>;
    committingTransaction(sessionId: string, transactionId: string): Promise<void>;
    abortingTransaction(sessionId: string, transactionId: string): Promise<void>;
}
export interface StompBrokerLayer {
    /**
     * Accept an incoming connection and creates a STOMP session
     * @param socket    Client Socket or WebSocket
     * @return New Session ID
     */
    accept<S extends GenericSocket>(socket: S): string;
    /**
     * Iterates all active subscriptions for the given destination, using the given callback
     * @param  destination The destination
     * @param  callback    The callback to execute for each subscription; to break the iteration, return false.
     */
    forDestination(destination: string, callback: (sessionId: string, subscription: Subscription) => boolean | void): void;
    sendMessage(message: StompMessage, destination: string): void;
    sendMessage(message: StompMessage, destination: string, sessionId: string): void;
}
export declare class StompBrokerLayerImpl implements StompBrokerLayer {
    readonly listener: StompBrokerListener;
    readonly config?: StompConfig | undefined;
    private readonly nextSessionId;
    readonly sessions: Map<string, StompServerSessionLayer>;
    readonly subscriptions: BrokerSubscriptionsRegistry;
    constructor(listener: StompBrokerListener, config?: StompConfig | undefined);
    accept<S extends GenericSocket>(socket: S): string;
    forDestination(destination: string, callback: (sessionId: string, subscription: Subscription) => boolean | void): void;
    sendMessage(message: StompMessage, destination: string): void;
    sendMessage(message: StompMessage, destination: string, sessionId: string): void;
    private sendToSession;
    sessionEnd(sessionId: string): void;
}
export interface Acknowledge {
    value: boolean;
    messageId: string;
    subscription?: string;
    transaction?: string;
}
export interface Subscription {
    id: string;
    destination: string;
    ack: string;
}
export declare class BrokerSubscriptionsRegistry {
    private readonly bySessionId;
    private readonly byDestination;
    add(sessionId: string, subscription: Subscription): void;
    get(sessionId: string, subscriptionId: string): Subscription | undefined;
    remove(sessionId: string): boolean;
    remove(sessionId: string, subscriptionId: string): boolean;
    private removeFromDestinationMap;
    forSessionDestination(sessionId: string, destination: string, callback: (subscription: Subscription) => boolean | void): void;
    forDestination(destination: string, callback: (sessionId: string, subscription: Subscription) => boolean | void): void;
}
export declare class SessionSubscriptionsRegistry {
    readonly sessionId: string;
    private readonly byId;
    private readonly byDestination;
    constructor(sessionId: string);
    readonly destinations: IterableIterator<string>;
    add(subscription: Subscription): void;
    remove(id: string): boolean;
    get(id: string): Subscription | undefined;
    forDestination(destination: string, callback: (subscription: Subscription) => boolean): boolean;
}
