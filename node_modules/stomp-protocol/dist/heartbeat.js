"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const model_1 = require("./model");
const timers_1 = require("timers");
class Heartbeat {
    constructor(frameLayer, options = Heartbeat.defaultOptions) {
        this.frameLayer = frameLayer;
        this.lastIncoming = 0;
        this.incomingTimer = null;
        this.outgoingTimer = null;
        this.options = options;
        this.optionsString = `${this.options.outgoingPeriod},${this.options.incomingPeriod}`;
        this.frameLayer.emitter.on("frame", (frame) => this.onFrame(frame));
        this.frameLayer.stream.emitter.on("data", (data) => this.onData(data));
        this.frameLayer.emitter.on("end", () => {
            this.releaseTimers();
        });
    }
    onData(data) {
        this.lastIncoming = Date.now();
    }
    onFrame(frame) {
        if (frame.command === "CONNECT" || frame.command === "CONNECTED") {
            const heartbeat = frame.headers["heart-beat"];
            if (!heartbeat) {
                return;
            }
            this.init(heartbeat);
        }
        this.lastIncoming = Date.now();
    }
    init(heartbeat) {
        const [remoteOutgoingPeriod, remoteIncomingPeriod] = heartbeat.split(",").map(s => Number(s));
        const localIncomingPeriod = this.options.incomingPeriod;
        if (localIncomingPeriod > 0 && remoteOutgoingPeriod > 0) {
            this.incomingPeriod = Math.max(localIncomingPeriod, remoteOutgoingPeriod);
            this.setupIncomingTimer();
        }
        const localOutgoingPeriod = this.options.outgoingPeriod;
        if (localOutgoingPeriod > 0 && remoteIncomingPeriod > 0) {
            this.outgoingPeriod = Math.max(localOutgoingPeriod, remoteIncomingPeriod);
            this.setupOutgoingTimer();
        }
    }
    setupOutgoingTimer() {
        const period = this.outgoingPeriod;
        if (period && period > 0) {
            this.outgoingTimer = setInterval(() => {
                const eol = "\0";
                this.frameLayer.stream.send(eol);
            }, period);
        }
    }
    resetupOutgoingTimer() {
        if (this.outgoingTimer) {
            this.releaseTimer(this.outgoingTimer);
            this.setupOutgoingTimer();
        }
    }
    releaseTimer(timer) {
        timer && timers_1.clearInterval(timer);
    }
    releaseTimers() {
        this.releaseTimer(this.incomingTimer);
        this.incomingTimer = null;
        this.releaseTimer(this.outgoingTimer);
        this.outgoingTimer = null;
    }
    setupIncomingTimer() {
        const period = this.incomingPeriod;
        if (period && period > 0) {
            this.incomingTimer = setInterval(() => {
                const delta = Date.now() - this.lastIncoming;
                if (delta > 2 * period && this.lastIncoming > 0) {
                    this.frameLayer.close();
                    this.frameLayer.error(new model_1.StompError(`No heartbeat for the last 2*${period} ms`));
                }
            }, period);
        }
    }
}
exports.Heartbeat = Heartbeat;
Heartbeat.defaultOptions = { outgoingPeriod: 0, incomingPeriod: 0 };
