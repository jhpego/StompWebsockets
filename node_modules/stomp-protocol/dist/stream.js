"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const model_1 = require("./model");
const utils_1 = require("./utils");
const net_1 = require("net");
function openStream(socket) {
    if (socket instanceof net_1.Socket) {
        return new StompSocketStreamLayer(socket);
    }
    if (isWebSocket(socket)) {
        return new StompWebSocketStreamLayer(socket);
    }
    throw new Error('Unsupported socket type');
}
exports.openStream = openStream;
function isWebSocket(socket) {
    return !!socket &&
        typeof socket.on === "function" &&
        typeof socket.send === "function" &&
        typeof socket.close === "function" &&
        socket.CLOSED === 3 &&
        socket.CLOSING === 2 &&
        socket.OPEN === 1 &&
        socket.CONNECTING === 0;
}
class StompSocketStreamLayer {
    constructor(socket) {
        this.socket = socket;
        this.emitter = new model_1.StompEventEmitter();
        utils_1.log.debug("StompSocketStreamLayer: new connection %s", socket.remoteAddress);
        this.socket.on('data', (data) => this.onSocketData(data));
        this.socket.on('error', (err) => this.onSocketEnd(err));
        this.socket.on('end', () => this.onSocketEnd());
    }
    onSocketData(data) {
        utils_1.log.silly("StompSocketStreamLayer: received data %j", data);
        if (this.emitter) {
            this.emitter.emit('data', data);
        }
    }
    onSocketEnd(err) {
        try {
            utils_1.log.debug("StompSocketStreamLayer: socket closed due to error %O", err);
            if (this.emitter) {
                this.emitter.emit('end', err);
            }
        }
        finally {
            this.socket.end();
        }
    }
    send(data) {
        return __awaiter(this, void 0, void 0, function* () {
            utils_1.log.silly("StompSocketStreamLayer: sending data %j", data);
            return new Promise((resolve, reject) => {
                try {
                    this.socket.write(data, resolve);
                }
                catch (err) {
                    utils_1.log.debug("StompSocketStreamLayer: error while sending data %O", err);
                    reject(err);
                }
            });
        });
    }
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            utils_1.log.debug("StompSocketStreamLayer: closing");
            return new Promise((resolve, reject) => {
                try {
                    this.socket.end(resolve);
                }
                catch (err) {
                    utils_1.log.debug("StompSocketStreamLayer: error while closing %O", err);
                    reject(err);
                }
            });
        });
    }
}
class StompWebSocketStreamLayer {
    constructor(webSocket) {
        this.webSocket = webSocket;
        this.emitter = new model_1.StompEventEmitter();
        this.messageListener = (event) => this.onWsMessage(event.data);
        this.errorListener = (event) => this.onWsEnd(event);
        this.closeListener = (code) => this.onWsEnd({ code });
        utils_1.log.debug("StompWebSocketStreamLayer: new connection");
        this.webSocket.addEventListener('message', this.messageListener);
        this.webSocket.addEventListener('error', this.errorListener);
        this.webSocket.addEventListener('close', this.closeListener);
    }
    onWsMessage(data) {
        utils_1.log.silly("StompWebSocketStreamLayer: received data %O", data);
        this.emitter.emit('data', new Buffer(data.toString()));
    }
    removeListeners() {
        this.webSocket.removeEventListener('message', this.messageListener);
        this.webSocket.removeEventListener('error', this.errorListener);
        this.webSocket.removeEventListener('close', this.closeListener);
    }
    onWsEnd(event) {
        utils_1.log.debug("StompWebSocketStreamLayer: WebSocket closed %O", event);
        this.wsClose();
    }
    send(data) {
        return __awaiter(this, void 0, void 0, function* () {
            utils_1.log.silly("StompWebSocketStreamLayer: sending data %j", data);
            return new Promise((resolve, reject) => {
                try {
                    this.webSocket.send(data);
                }
                catch (err) {
                    utils_1.log.debug("StompWebSocketStreamLayer: error while sending data %O", err);
                    reject(err);
                }
                finally {
                    resolve();
                }
            });
        });
    }
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            utils_1.log.debug("StompWebSocketStreamLayer: closing");
            return new Promise((resolve, reject) => {
                try {
                    this.wsClose();
                }
                catch (err) {
                    utils_1.log.debug("StompWebSocketStreamLayer: error while closing %O", err);
                    reject(err);
                }
                finally {
                    resolve();
                }
            });
        });
    }
    wsClose() {
        this.removeListeners();
        this.emitter.emit('end');
        this.webSocket.close();
    }
}
